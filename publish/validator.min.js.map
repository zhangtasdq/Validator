{"version":3,"sources":["webpack://RuleValidator/webpack/universalModuleDefinition","webpack://RuleValidator/webpack/bootstrap","webpack://RuleValidator/./src/impl/Engine.ts","webpack://RuleValidator/./src/impl/ExecutorFactory.ts","webpack://RuleValidator/./src/impl/GroupExecutor.ts","webpack://RuleValidator/./src/impl/SingleExecutor.ts","webpack://RuleValidator/./src/impl/Parser.ts","webpack://RuleValidator/./src/impl/OperatorFactory.ts","webpack://RuleValidator/./src/impl/Operator.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ExecutorFactory_1","Parser_1","OperatorFactory_1","Engine","contextData","this","executorFactory","operatorFactory","parser","currentRule","addRule","rule","setExecutorFactory","setOperatorFactory","parse","run","target","successCallback","errorCallback","executor","Error","result","execute","status","addGroupExecutor","addOperator","operator","GroupExecutor_1","SingleExecutor_1","andExecutor","children","j","length","orExecutor","itemResult","GroupExecutorFactory","groupExecutors","groupExecutorBuilder","_super","class_1","__extends","buildSingleExecutor","buildGroupExecutor","Group","GroupExecutor","childrens","addChild","executorItem","push","SingleExecutor","getObjValueByPath","path","pathArray","replace","split","tempTarget","getCurrentValue","current","getTargetValue","targetType","targetValue","currentValue","errorMsg","Parse","keys","parseGroup","parseSingle","getOperator","Operator_1","equalCallback","shadowEqual","notEqual","lessThan","lessThanInclusive","greaterThan","greaterThanInclusive","contains","indexOf","OperatorFactory","operators","callback","Operator"],"mappings":"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","file":"validator.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RuleValidator\"] = factory();\n\telse\n\t\troot[\"RuleValidator\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import EngineInterface from \"../interface/EngineInterface\";\nimport ExecutorInterface from \"../interface/ExecutorInterface\";\nimport ExecutorFactory from \"./ExecutorFactory\";\nimport ExecutorResult from \"../interface/ExecutorResult\";\nimport Parser from \"./Parser\"\nimport OperatorFactory from \"./OperatorFactory\";\n\nclass Engine implements EngineInterface {\n    private executorFactory: ExecutorFactory;\n    private currentRule:{[key:string]: ExecutorInterface};\n    private parser:Parser;\n    private contextData:Object;\n    private operatorFactory:OperatorFactory;\n\n    constructor(contextData = {}) {\n        this.executorFactory = new ExecutorFactory();\n        this.operatorFactory = new OperatorFactory();\n        this.parser = new Parser();\n        this.contextData = contextData;\n        this.currentRule = {};\n    }\n\n    addRule(key:string, rule:Object) {\n        this.parser.setExecutorFactory(this.executorFactory);\n        this.parser.setOperatorFactory(this.operatorFactory);\n        this.currentRule[key] = this.parser.parse(rule);\n    }\n\n    run(key:string, target:Object, successCallback: () => any, errorCallback?:(result:Object) => any) {\n        let executor = this.currentRule[key];\n        if (!executor) {\n            throw new Error(`规则 ${key} 不存在!`);\n        }\n        let result = executor.execute(target, this.contextData);\n        if (result.status) {\n            successCallback();\n        } else if(errorCallback){\n            errorCallback(result);\n        }\n    }\n\n    addGroupExecutor(key:string, executor: (children: ExecutorInterface[], target:Object, contextData:Object) => ExecutorResult) {\n        this.executorFactory.addGroupExecutor(key, executor);\n    }\n\n    addOperator(key:string, operator:(currentValue:any, targetValue:any) => boolean) {\n        this.operatorFactory.addOperator(key, operator);\n    }\n}\n\nexport default Engine;\n","import ExecutorResult from \"../interface/ExecutorResult\";\nimport ExecutorInterface from \"../interface/ExecutorInterface\";\nimport GroupExecutor from \"./GroupExecutor\";\nimport SingleExecutor from \"./SingleExecutor\";\nimport Operator from \"./Operator\";\nimport {SingleRuleInterface} from \"../interface/SingleRuleInterface\";\n\nlet andExecutor = (children: ExecutorInterface[], target:Object, contextData: Object) => {\n    let result = {status: true};\n\n    for(let i = 0, j = children.length; i < j; ++i) {\n        result = children[i].execute(target, contextData);\n        if (!result.status) {\n            break;\n        }\n    }\n    return result;\n};\n\nlet orExecutor = (children: ExecutorInterface[], target:Object, contextData:Object) => {\n    let itemResult = null;\n\n    for(let i = 0, j = children.length; i < j; ++i) {\n        itemResult = children[i].execute(target, contextData);\n\n        if (itemResult.status) {\n            break;\n        }\n    }\n    return itemResult;\n};\n\nclass GroupExecutorFactory {\n    private groupExecutors: Object;\n\n    constructor() {\n        this.groupExecutors = {};\n        this.addGroupExecutor(\"and\", andExecutor);\n        this.addGroupExecutor(\"or\", orExecutor);\n    }\n\n    private groupExecutorBuilder(name:string, executor: (children: ExecutorInterface[], target:Object, contextData:Object) => ExecutorResult):typeof GroupExecutor {\n        return class extends GroupExecutor {\n            constructor() {\n                super(name, executor);\n            }\n        }\n    }\n\n    addGroupExecutor(name:string, executor: (children: ExecutorInterface[], target:Object, contextData:Object) => ExecutorResult):void {\n        this.groupExecutors[name] = this.groupExecutorBuilder(name, executor);\n    }\n\n    buildSingleExecutor(rule:any, operator:Operator):SingleExecutor {\n        rule = <SingleRuleInterface> rule;\n        return new SingleExecutor(\"singleExecutor\", rule, operator);\n    }\n\n    buildGroupExecutor(name:string):GroupExecutor {\n        let Group = this.groupExecutors[name];\n        if (!Group) {\n            throw new Error(`组 ${name} 不存在!`);\n        }\n        return new Group();\n    }\n}\n\nexport default GroupExecutorFactory;\n","import ExecutorResult from \"../interface/ExecutorResult\";\nimport ExecutorInterface from \"../interface/ExecutorInterface\";\n\nclass GroupExecutor implements ExecutorInterface {\n    readonly name:string;\n    private childrens:ExecutorInterface[];\n    private executor: (children: ExecutorInterface[], target:Object, contextData:Object) => ExecutorResult;\n\n    constructor(name:string, executor: (children: ExecutorInterface[], target:Object, contextData:Object) => ExecutorResult) {\n        this.name = name;\n        this.executor = executor;\n        this.childrens = [];\n    }\n\n    execute(target:Object, contextData:Object):ExecutorResult  {\n        return this.executor(this.childrens, target, contextData);\n    }\n\n    addChild(executorItem: ExecutorInterface) {\n        this.childrens.push(executorItem);\n    }\n}\n\nexport default GroupExecutor;\n","import ExecutorResult from \"../interface/ExecutorResult\";\nimport ExecutorInterface from \"../interface/ExecutorInterface\";\nimport Operator from \"./Operator\";\nimport {SingleRuleInterface} from \"../interface/SingleRuleInterface\";\n\nclass SingleExecutor implements ExecutorInterface {\n    readonly name:string;\n    private rule:SingleRuleInterface;\n    private operator:Operator;\n\n    constructor(name:string, rule:SingleRuleInterface, operator:Operator) {\n        this.name = name;\n        this.rule = rule;\n        this.operator = operator;\n    }\n\n    private getObjValueByPath(target:Object, path:string):any {\n        path = path.replace(/\\[(\\w+)\\]/, \".$1\");\n        path = path.replace(/^\\./, \"\");\n\n        let pathArray = path.split(\".\"),\n            tempTarget = target,\n            i = 0,\n            j = pathArray.length;\n\n        for(; i < j; ++i) {\n            let key = pathArray[i];\n\n            if (tempTarget.hasOwnProperty(key)) {\n                tempTarget = tempTarget[key];\n            } else {\n                break;\n            }\n        }\n\n        if (i === pathArray.length) {\n            return tempTarget;\n        }\n        return null;\n    }\n\n    private getCurrentValue(current:Object):any  {\n        let value = this.getObjValueByPath(current, this.rule.key);\n        return value;\n    }\n\n    private getTargetValue(target:Object):any {\n        if (!this.rule.targetType || this.rule.targetType === \"plainValue\") {\n            return this.rule.targetValue;\n        }\n        return this.getObjValueByPath(target, this.rule.targetValue);\n    }\n\n    execute(current:Object, contextData:Object):ExecutorResult {\n        let currentValue = this.getCurrentValue(current),\n            targetValue = this.getTargetValue(contextData);\n\n        if (this.operator.run(currentValue, targetValue)) {\n            return {status: true};\n        }\n        return {status: false, errorMsg: this.rule.errorMsg};\n    }\n}\n\nexport default SingleExecutor;\n","import ExecutorInterface from \"../interface/ExecutorInterface\";\nimport ExecutorFactory from \"./ExecutorFactory\";\nimport OperatorFactory from \"./OperatorFactory\";\n\nclass Parse {\n    private executorFactory: ExecutorFactory;\n    private operatorFactory: OperatorFactory;\n\n    parse(rule:Object):ExecutorInterface {\n        let result,\n            keys = Object.keys(rule);\n\n        if(keys.length === 1) {\n            result = this.parseGroup(keys[0], rule[keys[0]]);\n        } else {\n            result = this.parseSingle(rule);\n        }\n        return result;\n    }\n\n    parseGroup(key:string, rule:Object[]):ExecutorInterface {\n        let executor = this.executorFactory.buildGroupExecutor(key);\n\n        for(let i = 0, j = rule.length; i < j; ++i) {\n            executor.addChild(this.parse(rule[i]));\n        }\n\n        return executor;\n    }\n\n    parseSingle(rule:any):ExecutorInterface {\n        let operator = this.operatorFactory.getOperator(rule.operator);\n        return this.executorFactory.buildSingleExecutor(rule, operator);\n    }\n\n    setExecutorFactory(executorFactory:ExecutorFactory):void {\n        this.executorFactory = executorFactory;\n    }\n\n    setOperatorFactory(operatorFactory:OperatorFactory):void {\n        this.operatorFactory = operatorFactory;\n    }\n}\n\nexport default Parse;\n","import Operator from \"./Operator\";\n\nlet equalCallback = (currentValue:any, targetValue:any) => {\n    return currentValue === targetValue;\n}\n\nlet shadowEqual = (currentValue:any, targetValue:any) => {\n    return currentValue == targetValue;\n}\n\nlet notEqual = (currentValue:any, targetValue:any) => {\n    return currentValue !== targetValue;\n}\n\nlet lessThan = (currentValue:any, targetValue:any) => {\n    return currentValue < targetValue;\n}\n\nlet lessThanInclusive = (currentValue:any, targetValue:any) => {\n    return currentValue <= targetValue;\n};\n\nlet greaterThan = (currentValue:any, targetValue:any) => {\n    return currentValue > targetValue;\n};\n\nlet greaterThanInclusive = (currentValue:any, targetValue:any) => {\n    return currentValue >= targetValue;\n};\n\nlet contains = (currentValue, targetValue:any) => {\n    return currentValue.indexOf && currentValue.indexOf(targetValue) !== -1;\n};\n\nclass OperatorFactory {\n    private operators:{[key:string]: Operator};\n\n    constructor() {\n        this.operators = {};\n        this.addOperator(\"equal\", equalCallback);\n        this.addOperator(\"shadowEqual\", shadowEqual);\n        this.addOperator(\"notEqual\", notEqual);\n        this.addOperator(\"lessThan\", lessThan);\n        this.addOperator(\"lessThanInclusive\", lessThanInclusive);\n        this.addOperator(\"greaterThan\", greaterThan);\n        this.addOperator(\"greaterThanInclusive\", greaterThanInclusive);\n        this.addOperator(\"contains\", contains);\n    }\n\n    addOperator(name:string, callback:(currentValue: any, targetValue: any) => boolean):void {\n        this.operators[name] = new Operator(name, callback);\n    }\n\n    getOperator(name:string):Operator {\n        let result = this.operators[name];\n        if (!result) {\n            throw new Error(`操作 ${name} 不存在!`);\n        }\n        return result;\n    }\n}\n\nexport default OperatorFactory;\n","import OperatorInterface from \"../interface/OperatorInterface\";\n\nclass Operator implements OperatorInterface {\n   readonly name:string;\n   private executor: (currentValue:any, targetValue) => boolean;\n\n   constructor(name:string, executor: (currentValue:any, targetValue:any) => boolean) {\n       this.name = name;\n       this.executor = executor;\n   }\n\n    run(currentValue:any, targetValue:any):boolean {\n        return this.executor(currentValue, targetValue);\n    }\n}\n\nexport default Operator;\n"],"sourceRoot":""}